# -*- coding: utf-8 -*-
"""IPL Score Prediction using Deep Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lNokWd1-I2qyV27aw0_AAMvBF2EQZeEc

# **IPL Score Prediction using Deep Learning**

### ***By Dhruv Boricha***

In the current age of cricket analytics, where each run and each decision can alter the outcome, the application of Deep Learning for IPL score prediction is at the cutting edge of technology. The project explores the cutting-edge application of advanced algorithms for IPL score prediction in live matches with high accuracy.

We humans can't simply recognize patterns from huge data, and thus comes machine learning and IPL score prediction through deep learning. These sophisticated methods learn from the way players and teams have played each other in the past, creating models to forecast outcomes more precisely.

## **Step 1: Import necessary libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import preprocessing
import keras
import tensorflow as tf

"""## **Step 2: Loading the Dataset**"""

ipl = pd.read_csv("/content/ipl_data.csv")
ipl.head()

"""## **Step 3: Data Pre-processing**"""

#Dropping certain features
df = ipl.drop(['date', 'runs', 'wickets', 'overs', 'runs_last_5', 'wickets_last_5','mid', 'striker', 'non-striker'], axis =1)

X = df.drop(['total'], axis =1)
y = df['total']

#Label Encoding

from sklearn.preprocessing import LabelEncoder

# Create a LabelEncoder object for each categorical feature
venue_encoder = LabelEncoder()
batting_team_encoder = LabelEncoder()
bowling_team_encoder = LabelEncoder()
striker_encoder = LabelEncoder()
bowler_encoder = LabelEncoder()

# Fit and transform the categorical features with label encoding
X['venue'] = venue_encoder.fit_transform(X['venue'])
X['bat_team'] = batting_team_encoder.fit_transform(X['bat_team'])
X['bowl_team'] = bowling_team_encoder.fit_transform(X['bowl_team'])
X['batsman'] = striker_encoder.fit_transform(X['batsman'])
X['bowler'] = bowler_encoder.fit_transform(X['bowler'])

# Train test Split
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

# Fit the scaler on the training data and transform both training and testing data
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""## **Step 4: Define the Neural Network**

*   We have defined a neural network using TensorFlow and Keras for regression.
*   After defining the model, we have compiled the model using the Huber Loss because of the robustness of the regression against outliers.

"""

# Define the neural network model
model = keras.Sequential([
    keras.layers.Input( shape=(X_train_scaled.shape[1],)),  # Input layer
    keras.layers.Dense(512, activation='relu'),  # Hidden layer with 512 units and ReLU activation
    keras.layers.Dense(216, activation='relu'),  # Hidden layer with 216 units and ReLU activation
    keras.layers.Dense(1, activation='linear')  # Output layer with linear activation for regression
])

# Compile the model with Huber loss
huber_loss = tf.keras.losses.Huber(delta=1.0)  # You can adjust the 'delta' parameter as needed
model.compile(optimizer='adam', loss=huber_loss)  # Use Huber loss for regression

"""## **Step 5: Model Training**

*   We have trained the neural network model using the scaled training data.
*   After the training, we have stored the training and validation loss values to our neural network during the training process.
"""

# Train the model
model.fit(X_train_scaled, y_train, epochs=50, batch_size=64, validation_data=(X_test_scaled, y_test))

model_losses = pd.DataFrame(model.history.history)
model_losses.plot()

"""## **Step 6: Model Evaluation**


*   We have predicted using the trained neural network on the testing data.
*   The variable predictions contains the predicted total run scores for the test set based on the model’s learned patterns.
"""

# Make predictions
predictions = model.predict(X_test_scaled)

from sklearn.metrics import mean_absolute_error,mean_squared_error
mean_absolute_error(y_test,predictions)

"""## **Step 7: Creating an Interactive Widget**

We have created an interactive dropdown widget using ipywidgets to predict the score based on user input for venue, batting team, bowling team, striker, and bowler.

Then, we have added a “Predicted Score” button widget. Whenever, the button will be clicked, the predict_score function will be called and then perform the following steps:
*   Decodes the user-selected values to their original categorical values.
*   Encodes and scales these values to match the format used in model training.
*   Uses the trained model to make a prediction based on the user’s input.
*   Displays the predicted score.
"""

import ipywidgets as widgets
from IPython.display import display, clear_output

import warnings
warnings.filterwarnings("ignore")

venue = widgets.Dropdown(options=df['venue'].unique().tolist(),description='Select Venue:')
batting_team = widgets.Dropdown(options =df['bat_team'].unique().tolist(),  description='Select Batting Team:')
bowling_team = widgets.Dropdown(options=df['bowl_team'].unique().tolist(),  description='Select Bowling Team:')
striker = widgets.Dropdown(options=df['batsman'].unique().tolist(), description='Select Striker:')
bowler = widgets.Dropdown(options=df['bowler'].unique().tolist(), description='Select Bowler:')

predict_button = widgets.Button(description="Predict Score")

def predict_score(b):
    with output:
        clear_output()  # Clear the previous output


        # Decode the encoded values back to their original values
        decoded_venue = venue_encoder.transform([venue.value])
        decoded_batting_team = batting_team_encoder.transform([batting_team.value])
        decoded_bowling_team = bowling_team_encoder.transform([bowling_team.value])
        decoded_striker = striker_encoder.transform([striker.value])
        decoded_bowler = bowler_encoder.transform([bowler.value])


        input = np.array([decoded_venue,  decoded_batting_team, decoded_bowling_team,decoded_striker, decoded_bowler])
        input = input.reshape(1,5)
        input = scaler.transform(input)
        #print(input)
        predicted_score = model.predict(input)
        predicted_score = int(predicted_score[0,0])

        print(predicted_score)

predict_button.on_click(predict_score)
output = widgets.Output()
display(venue, batting_team, bowling_team, striker, bowler, predict_button, output)

"""We have predicted the score of the match between Mumbai Indians and Chennai Super Kings in Wankhede Stadium. The predicted score of the match is 158.

### ***Summary***

By harnessing the power of ML and DL, we have successfully predicted the cricket scores based on historical data. The model’s ability to predict cricket scores can be a valuable asset for IPL enthusiasts, teams, and analysts. It can provide insights into the dynamics of a match and help anticipate how different factors impact the final score.
"""